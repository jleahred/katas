# PROCRUST

## TODO

* depends_on.
    * if a process stops or is detected as stopped, stop all dependent processes
    * additionally, do not start until the dependent process is running
* health_check. if it fails, restart and do not mark as running until it returns ok
* ready_check. after starting, do not mark as running until it returns ok
* add kind oneshot/normal/cancelled
* tui
* groups
* detect zombie processes
* run-once
* startup parameters
    * allow specifying a configuration file, logs, tui...
* execution retries
    * specify frequency and possibly the number of attempts

## Description

The goal is to create a simple and secure tool to schedule and manage the startup of multiple services on a machine.

It will work with a text file (currently a TOML configuration) for management.

It is declarative; the system will adjust the service configuration to match the document.

Although it may seem like a supervisor, it has some of the characteristics but intentionally lacks others.

It is not intended to replace mature and high-quality tools like systemd, supervisord, or Kubernetes.

It must be a small, lightweight, and non-critical program.

It is not designed to start many services very quickly or work with a cluster.

It will not attempt to start many services simultaneously in parallel, as this could cause bottlenecks in already running services.

If this program stops (due to an error, failure, or intentionally), it should not stop all "managed" services.

Once restarted, it should continue monitoring and managing.

### Examples of service configurations

The configuration will start with an identifier for the services to be managed and the configuration file format.

```toml
uid = "550e8400-e29b-41d4-a716-446655440000"
file_format = "0"
```

The identifier can be generated by passing `uid` as a parameter to the program.

#### Example of a process configuration

```toml
[[process]]
id = "example_process"
command = "echo 'Hello, World!' && sleep 10"
apply_on = "2023-10-01T12:00:00"
type = "normal"                              # optional  normal/fake
start_time = "09:00:00"                      # optional
stop_time = "23:00:00"                       # optional
week_days = ["mon", "wed", "thu", "fri"]     # optional  
# week_days = "mon-fri"   # also valid
```

If only the command line is changed, the system will not restart the service (this is intentional).

It is not good practice to change only the command line, and restarting the service is a delicate operation.

#### Program a future new version

Suppose we want to apply a change to service A for startup tomorrow

```toml
# current version running
[[process]]
id = "SERVICE_A"
command = "echo $(date)  '  bb'"
apply_on = "2023-10-01T08:00:00"

# next version to run
[[process]]
id = "SERVICE_A"
command = "echo $(date)  '  bb'; sleep 1; echo $(date)  '  bb'; sleep 1; echo $(date)  '  bb'; sleep 1"
apply_on = "2025-04-01T08:00:00"
```

We see that the service is defined twice.

One configuration started applying in October 2023.

The next configuration will apply on April 1, 2025, at 8:00 AM.

Since it has no start and stop time, it is a 24x7 service.

On April 1, 2025, at 8:00 AM, the first configuration will stop, and once the stop is confirmed, the second option for `SERVICE_A` will execute.

#### Rollback

To perform a rollback, we can mark the new version as `fake`

```toml
# current version running
[[process]]
id = "SERVICE_A"
command = "echo $(date)  '  bb'"
apply_on = "2023-10-01T08:00:00"

# next version to run
[[process]]
type = "fake"
id = "SERVICE_A"
command = "echo $(date)  '  bb'; sleep 1; echo $(date)  '  bb'; sleep 1; echo $(date)  '  bb'; sleep 1"
apply_on = "2025-04-01T08:00:00"
```


